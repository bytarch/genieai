"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5512],{"(app-pages-browser)/./node_modules/lodash-es/clone.js":(e,n,r)=>{r.d(n,{A:()=>a});var t=r("(app-pages-browser)/./node_modules/lodash-es/_baseClone.js");let a=function(e){return(0,t.A)(e,4)}},"(app-pages-browser)/./node_modules/mermaid/dist/chunks/mermaid.core/dagre-4EVJKHTY.mjs":(e,n,r)=>{r.r(n),r.d(n,{render:()=>I});var t=r("(app-pages-browser)/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-66SQ7PYY.mjs"),a=r("(app-pages-browser)/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-7NZE2EM7.mjs");r("(app-pages-browser)/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-OPO4IU42.mjs"),r("(app-pages-browser)/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-3JNJP5BE.mjs");var d=r("(app-pages-browser)/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-3X56UNUX.mjs");r("(app-pages-browser)/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-6JOS74DS.mjs"),r("(app-pages-browser)/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-7DKRZKHE.mjs");var i=r("(app-pages-browser)/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-6DBFFHIP.mjs"),s=r("(app-pages-browser)/./node_modules/dagre-d3-es/src/dagre/index.js"),o=r("(app-pages-browser)/./node_modules/lodash-es/isUndefined.js"),l=r("(app-pages-browser)/./node_modules/lodash-es/clone.js"),g=r("(app-pages-browser)/./node_modules/lodash-es/map.js");function c(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:g.A(e.nodes(),function(n){var r=e.node(n),t=e.parent(n),a={v:n};return o.A(r)||(a.value=r),o.A(t)||(a.parent=t),a}),edges:g.A(e.edges(),function(n){var r=e.edge(n),t={v:n.v,w:n.w};return o.A(n.name)||(t.name=n.name),o.A(r)||(t.value=r),t})};return o.A(e.graph())||(n.value=l.A(e.graph())),n}r("(app-pages-browser)/./node_modules/dagre-d3-es/src/graphlib/graph.js");var m=r("(app-pages-browser)/./node_modules/dagre-d3-es/src/graphlib/index.js"),p=new Map,h=new Map,u=new Map,f=(0,i.K2)(()=>{h.clear(),u.clear(),p.clear()},"clear"),w=(0,i.K2)((e,n)=>{let r=h.get(n)||[];return i.Rm.trace("In isDescendant",n," ",e," = ",r.includes(e)),r.includes(e)},"isDescendant"),R=(0,i.K2)((e,n)=>{let r=h.get(n)||[];return i.Rm.info("Descendants of ",n," is ",r),i.Rm.info("Edge is ",e),e.v!==n&&e.w!==n&&(r?r.includes(e.v)||w(e.v,n)||w(e.w,n)||r.includes(e.w):(i.Rm.debug("Tilt, ",n,",not in descendants"),!1))},"edgeInCluster"),v=(0,i.K2)((e,n,r,t)=>{i.Rm.warn("Copying children of ",e,"root",t,"data",n.node(e),t);let a=n.children(e)||[];e!==t&&a.push(e),i.Rm.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach(a=>{if(n.children(a).length>0)v(a,n,r,t);else{let d=n.node(a);i.Rm.info("cp ",a," to ",t," with parent ",e),r.setNode(a,d),t!==n.parent(a)&&(i.Rm.warn("Setting parent",a,n.parent(a)),r.setParent(a,n.parent(a))),e!==t&&a!==e?(i.Rm.debug("Setting parent",a,e),r.setParent(a,e)):(i.Rm.info("In copy ",e,"root",t,"data",n.node(e),t),i.Rm.debug("Not Setting parent for node=",a,"cluster!==rootId",e!==t,"node!==clusterId",a!==e));let s=n.edges(a);i.Rm.debug("Copying Edges",s),s.forEach(a=>{i.Rm.info("Edge",a);let d=n.edge(a.v,a.w,a.name);i.Rm.info("Edge data",d,t);try{R(a,t)?(i.Rm.info("Copying as ",a.v,a.w,d,a.name),r.setEdge(a.v,a.w,d,a.name),i.Rm.info("newGraph edges ",r.edges(),r.edge(r.edges()[0]))):i.Rm.info("Skipping copy of edge ",a.v,"--\x3e",a.w," rootId: ",t," clusterId:",e)}catch(e){i.Rm.error(e)}})}i.Rm.debug("Removing node",a),n.removeNode(a)})},"copy"),y=(0,i.K2)((e,n)=>{let r=n.children(e),t=[...r];for(let a of r)u.set(a,e),t=[...t,...y(a,n)];return t},"extractDescendants"),b=(0,i.K2)((e,n,r)=>{let t=e.edges().filter(e=>e.v===n||e.w===n),a=e.edges().filter(e=>e.v===r||e.w===r),d=t.map(e=>({v:e.v===n?r:e.v,w:e.w===n?n:e.w})),i=a.map(e=>({v:e.v,w:e.w}));return d.filter(e=>i.some(n=>e.v===n.v&&e.w===n.w))},"findCommonEdges"),X=(0,i.K2)((e,n,r)=>{let t;let a=n.children(e);if(i.Rm.trace("Searching children of id ",e,a),a.length<1)return e;for(let e of a){let a=X(e,n,r),d=b(n,r,a);if(a){if(!(d.length>0))return a;t=a}}return t},"findNonClusterChild"),E=(0,i.K2)(e=>p.has(e)&&p.get(e).externalConnections&&p.has(e)?p.get(e).id:e,"getAnchorId"),N=(0,i.K2)((e,n)=>{if(!e||n>10){i.Rm.debug("Opting out, no graph ");return}for(let n of(i.Rm.debug("Opting in, graph "),e.nodes().forEach(function(n){e.children(n).length>0&&(i.Rm.warn("Cluster identified",n," Replacement id in edges: ",X(n,e,n)),h.set(n,y(n,e)),p.set(n,{id:X(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){let r=e.children(n),t=e.edges();r.length>0?(i.Rm.debug("Cluster identified",n,h),t.forEach(e=>{w(e.v,n)^w(e.w,n)&&(i.Rm.warn("Edge: ",e," leaves cluster ",n),i.Rm.warn("Descendants of XXX ",n,": ",h.get(n)),p.get(n).externalConnections=!0)})):i.Rm.debug("Not a cluster ",n,h)}),p.keys())){let r=p.get(n).id,t=e.parent(r);t!==n&&p.has(t)&&!p.get(t).externalConnections&&(p.get(n).id=t)}e.edges().forEach(function(n){let r=e.edge(n);i.Rm.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),i.Rm.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let t=n.v,a=n.w;if(i.Rm.warn("Fix XXX",p,"ids:",n.v,n.w,"Translating: ",p.get(n.v)," --- ",p.get(n.w)),p.get(n.v)||p.get(n.w)){if(i.Rm.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),t=E(n.v),a=E(n.w),e.removeEdge(n.v,n.w,n.name),t!==n.v){let a=e.parent(t);p.get(a).externalConnections=!0,r.fromCluster=n.v}if(a!==n.w){let t=e.parent(a);p.get(t).externalConnections=!0,r.toCluster=n.w}i.Rm.warn("Fix Replacing with XXX",t,a,n.name),e.setEdge(t,a,r,n.name)}}),i.Rm.warn("Adjusted Graph",c(e)),C(e,0),i.Rm.trace(p)},"adjustClustersAndEdges"),C=(0,i.K2)((e,n)=>{if(i.Rm.warn("extractor - ",n,c(e),e.children("D")),n>10){i.Rm.error("Bailing out");return}let r=e.nodes(),t=!1;for(let n of r){let r=e.children(n);t=t||r.length>0}if(!t){i.Rm.debug("Done, no node has children",e.nodes());return}for(let t of(i.Rm.debug("Nodes = ",r,n),r))if(i.Rm.debug("Extracting node",t,p,p.has(t)&&!p.get(t).externalConnections,!e.parent(t),e.node(t),e.children("D")," Depth ",n),p.has(t)){if(!p.get(t).externalConnections&&e.children(t)&&e.children(t).length>0){i.Rm.warn("Cluster without external connections, without a parent and with children",t,n);let r="TB"===e.graph().rankdir?"LR":"TB";p.get(t)?.clusterData?.dir&&(r=p.get(t).clusterData.dir,i.Rm.warn("Fixing dir",p.get(t).clusterData.dir,r));let a=new m.T({multigraph:!0,compound:!0}).setGraph({rankdir:r,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.Rm.warn("Old graph before copy",c(e)),v(t,e,a,t),e.setNode(t,{clusterNode:!0,id:t,clusterData:p.get(t).clusterData,label:p.get(t).label,graph:a}),i.Rm.warn("New graph after copy node: (",t,")",c(a)),i.Rm.debug("Old graph after copy",c(e))}else i.Rm.warn("Cluster ** ",t," **not meeting the criteria !externalConnections:",!p.get(t).externalConnections," no parent: ",!e.parent(t)," children ",e.children(t)&&e.children(t).length>0,e.children("D"),n),i.Rm.debug(p)}else i.Rm.debug("Not a cluster",t,n);for(let t of(r=e.nodes(),i.Rm.warn("New list of nodes",r),r)){let r=e.node(t);i.Rm.warn(" Now next level",t,r),r?.clusterNode&&C(r.graph,n+1)}},"extractor"),k=(0,i.K2)((e,n)=>{if(0===n.length)return[];let r=Object.assign([],n);return n.forEach(n=>{let t=e.children(n),a=k(e,t);r=[...r,...a]}),r},"sorter"),S=(0,i.K2)(e=>k(e,e.children()),"sortNodesByHierarchy"),x=(0,i.K2)(async(e,n,r,o,l,g)=>{i.Rm.warn("Graph in recursive render:XAX",c(n),l);let m=n.graph().rankdir;i.Rm.trace("Dir in recursive render - dir:",m);let h=e.insert("g").attr("class","root");n.nodes()?i.Rm.info("Recursive render XXX",n.nodes()):i.Rm.info("No nodes found for",n),n.edges().length>0&&i.Rm.info("Recursive edges",n.edge(n.edges()[0]));let u=h.insert("g").attr("class","clusters"),f=h.insert("g").attr("class","edgePaths"),w=h.insert("g").attr("class","edgeLabels"),R=h.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(e){let t=n.node(e);if(void 0!==l){let r=JSON.parse(JSON.stringify(l.clusterData));i.Rm.trace("Setting data for parent cluster XXX\n Node.id = ",e,"\n data=",r.height,"\nParent cluster",l.height),n.setNode(l.id,r),n.parent(e)||(i.Rm.trace("Setting parent",e,l.id),n.setParent(e,l.id,r))}if(i.Rm.info("(Insert) Node XXX"+e+": "+JSON.stringify(n.node(e))),t?.clusterNode){i.Rm.info("Cluster identified XBX",e,t.width,n.node(e));let{ranksep:d,nodesep:s}=n.graph();t.graph.setGraph({...t.graph.graph(),ranksep:d+25,nodesep:s});let l=await x(R,t.graph,r,o,n.node(e),g),c=l.elem;(0,a.lC)(t,c),t.diff=l.diff||0,i.Rm.info("New compound node after recursive render XAX",e,"width",t.width,"height",t.height),(0,a.U7)(c,t)}else n.children(e).length>0?(i.Rm.trace("Cluster - the non recursive path XBX",e,t.id,t,t.width,"Graph:",n),i.Rm.trace(X(t.id,n)),p.set(t.id,{id:X(t.id,n),node:t})):(i.Rm.trace("Node - the non recursive path XAX",e,R,n.node(e),m),await (0,a.on)(R,n.node(e),{config:g,dir:m}))}));let v=(0,i.K2)(async()=>{let e=n.edges().map(async function(e){let r=n.edge(e.v,e.w,e.name);i.Rm.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),i.Rm.info("Edge "+e.v+" -> "+e.w+": ",e," ",JSON.stringify(n.edge(e))),i.Rm.info("Fix",p,"ids:",e.v,e.w,"Translating: ",p.get(e.v),p.get(e.w)),await (0,t.jP)(w,r)});await Promise.all(e)},"processEdges");await v(),i.Rm.info("Graph before layout:",JSON.stringify(c(n))),i.Rm.info("############################################# XXX"),i.Rm.info("###                Layout                 ### XXX"),i.Rm.info("############################################# XXX"),(0,s.Zp)(n),i.Rm.info("Graph after layout:",JSON.stringify(c(n)));let y=0,{subGraphTitleTotalMargin:b}=(0,d.O)(g);return await Promise.all(S(n).map(async function(e){let r=n.node(e);if(i.Rm.info("Position XBX => "+e+": ("+r.x,","+r.y,") width: ",r.width," height: ",r.height),r?.clusterNode)r.y+=b,i.Rm.info("A tainted cluster node XBX1",e,r.id,r.width,r.height,r.x,r.y,n.parent(e)),p.get(r.id).node=r,(0,a.U_)(r);else if(n.children(e).length>0){i.Rm.info("A pure cluster node XBX1",e,r.id,r.x,r.y,r.width,r.height,n.parent(e)),r.height+=b,n.node(r.parentId);let t=r?.padding/2||0,d=r?.labelBBox?.height||0;i.Rm.debug("OffsetY",d-t||0,"labelHeight",d,"halfPadding",t),await (0,a.U)(u,r),p.get(r.id).node=r}else{let e=n.node(r.parentId);r.y+=b/2,i.Rm.info("A regular node XBX1 - using the padding",r.id,"parent",r.parentId,r.width,r.height,r.x,r.y,"offsetY",r.offsetY,"parent",e,e?.offsetY,r),(0,a.U_)(r)}})),n.edges().forEach(function(e){let a=n.edge(e);i.Rm.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(a),a),a.points.forEach(e=>e.y+=b/2);let d=n.node(e.v);var s=n.node(e.w);let l=(0,t.Jo)(f,a,p,r,d,s,o);(0,t.T_)(a,l)}),n.nodes().forEach(function(e){let r=n.node(e);i.Rm.info(e,r.type,r.diff),r.isGroup&&(y=r.diff)}),i.Rm.warn("Returning from recursive render XAX",h,y),{elem:h,diff:y}},"recursiveRender"),I=(0,i.K2)(async(e,n)=>{let r=new m.T({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),d=n.select("g");(0,t.g0)(d,e.markers,e.type,e.diagramId),(0,a.gh)(),(0,t.IU)(),(0,a.IU)(),f(),e.nodes.forEach(e=>{r.setNode(e.id,{...e}),e.parentId&&r.setParent(e.id,e.parentId)}),i.Rm.debug("Edges:",e.edges),e.edges.forEach(e=>{if(e.start===e.end){let n=e.start,t=n+"---"+n+"---1",a=n+"---"+n+"---2",d=r.node(n);r.setNode(t,{domId:t,id:t,parentId:d.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),r.setParent(t,d.parentId),r.setNode(a,{domId:a,id:a,parentId:d.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),r.setParent(a,d.parentId);let i=structuredClone(e),s=structuredClone(e),o=structuredClone(e);i.label="",i.arrowTypeEnd="none",i.id=n+"-cyclic-special-1",s.arrowTypeEnd="none",s.id=n+"-cyclic-special-mid",o.label="",d.isGroup&&(i.fromCluster=n,o.toCluster=n),o.id=n+"-cyclic-special-2",r.setEdge(n,t,i,n+"-cyclic-special-0"),r.setEdge(t,a,s,n+"-cyclic-special-1"),r.setEdge(a,n,o,n+"-cyc<lic-special-2")}else r.setEdge(e.start,e.end,{...e},e.id)}),i.Rm.warn("Graph at first:",JSON.stringify(c(r))),N(r),i.Rm.warn("Graph after XAX:",JSON.stringify(c(r)));let s=(0,i.D7)();await x(d,r,e.type,e.diagramId,void 0,s)},"render")}}]);